<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAR - Mouse Marker Detection</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: #0a0a0f;
            color: #e0e0e0;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 90vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #video-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #webcam {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            /*transform: scaleX(-1);*/
        }

        #canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /*transform: scaleX(-1);*/
        }

        #three-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 12px 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, transparent 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        @media (min-width: 768px) {
            .header {
                padding: 20px 30px;
            }
        }

        .logo {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            font-weight: 900;
            letter-spacing: 3px;
            background: linear-gradient(135deg, #ff3366 0%, #ff6b35 50%, #f7931e 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(255, 51, 102, 0.5);
        }

        .status-panel {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.7rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-item span:last-child {
            display: none;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #444;
            animation: pulse 2s infinite;
        }

        .status-dot.active {
            background: #00ff88;
            box-shadow: 0 0 10px #00ff88;
        }

        .status-dot.detecting {
            background: #ff3366;
            box-shadow: 0 0 10px #ff3366;
            animation: pulse-fast 0.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes pulse-fast {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.2); }
        }

        .info-panel {
            display: none;
        }

        .detection-info {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 15, 0.85);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 10px;
            padding: 12px 20px;
            backdrop-filter: blur(10px);
        }

        .detection-info h4 {
            display: none;
        }

        .detection-stats {
            display: flex;
            flex-direction: row;
            gap: 20px;
        }

        .stat-row {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 0.75rem;
        }

        .stat-label {
            color: #666;
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            color: #fff;
            font-weight: 700;
            font-family: 'Orbitron', monospace;
            font-size: 0.9rem;
        }

        /* Tablet and larger screens */
        @media (min-width: 768px) {
            .logo {
                font-size: 1.5rem;
                letter-spacing: 4px;
            }

            .status-panel {
                gap: 20px;
            }

            .status-item {
                font-size: 0.85rem;
                gap: 8px;
            }

            .status-item span:last-child {
                display: inline;
            }

            .status-dot {
                width: 10px;
                height: 10px;
            }

            .info-panel {
                display: block;
                position: absolute;
                bottom: 30px;
                left: 30px;
                background: rgba(10, 10, 15, 0.9);
                border: 1px solid rgba(255, 51, 102, 0.3);
                border-radius: 12px;
                padding: 20px;
                backdrop-filter: blur(10px);
                max-width: 320px;
            }

            .info-panel h3 {
                font-family: 'Orbitron', monospace;
                font-size: 0.9rem;
                font-weight: 700;
                color: #ff3366;
                margin-bottom: 12px;
                letter-spacing: 2px;
            }

            .info-panel p {
                font-size: 0.9rem;
                line-height: 1.6;
                color: #888;
            }

            .detection-info {
                position: absolute;
                bottom: 30px;
                right: 30px;
                left: auto;
                transform: none;
                padding: 20px;
                border-radius: 12px;
                min-width: 200px;
            }

            .detection-info h4 {
                display: block;
                font-family: 'Orbitron', monospace;
                font-size: 0.8rem;
                font-weight: 700;
                color: #00ff88;
                margin-bottom: 10px;
                letter-spacing: 2px;
            }

            .detection-stats {
                flex-direction: column;
                gap: 8px;
            }

            .stat-row {
                flex-direction: row;
                justify-content: space-between;
                font-size: 0.85rem;
            }

            .stat-label {
                font-size: 0.85rem;
                text-transform: none;
            }
        }

        .loading-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0f;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            padding: 20px;
        }

        .loading-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 51, 102, 0.1);
            border-top-color: #ff3366;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            font-family: 'Orbitron', monospace;
            font-size: 0.85rem;
            letter-spacing: 2px;
            color: #ff3366;
            margin-bottom: 8px;
        }

        .loading-status {
            font-size: 0.75rem;
            color: #666;
            text-align: center;
        }

        @media (min-width: 768px) {
            .loader {
                width: 80px;
                height: 80px;
                margin-bottom: 30px;
            }

            .loading-text {
                font-size: 1rem;
                letter-spacing: 3px;
            }

            .loading-status {
                font-size: 0.85rem;
            }
        }

        .corner-frame {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255, 51, 102, 0.4);
        }

        .corner-frame.tl {
            top: 10px;
            left: 10px;
            border-right: none;
            border-bottom: none;
        }

        .corner-frame.tr {
            top: 10px;
            right: 10px;
            border-left: none;
            border-bottom: none;
        }

        .corner-frame.bl {
            bottom: 10px;
            left: 10px;
            border-right: none;
            border-top: none;
        }

        .corner-frame.br {
            bottom: 10px;
            right: 10px;
            border-left: none;
            border-top: none;
        }

        @media (min-width: 768px) {
            .corner-frame {
                width: 60px;
                height: 60px;
            }

            .corner-frame.tl {
                top: 20px;
                left: 20px;
            }

            .corner-frame.tr {
                top: 20px;
                right: 20px;
            }

            .corner-frame.bl {
                bottom: 20px;
                left: 20px;
            }

            .corner-frame.br {
                bottom: 20px;
                right: 20px;
            }
        }

        .scan-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, rgba(255, 51, 102, 0.5), transparent);
            animation: scan 3s linear infinite;
            opacity: 0.5;
        }

        @keyframes scan {
            0% { top: 0; }
            100% { top: 100%; }
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 51, 102, 0.1);
            border: 1px solid #ff3366;
            border-radius: 12px;
            padding: 20px 25px;
            text-align: center;
            z-index: 500;
            display: none;
            max-width: 90%;
            width: 280px;
        }

        .error-message.show {
            display: block;
        }

        .error-message h3 {
            font-family: 'Orbitron', monospace;
            font-size: 0.85rem;
            color: #ff3366;
            margin-bottom: 10px;
        }

        .error-message p {
            color: #888;
            font-size: 0.8rem;
            line-height: 1.5;
        }

        @media (min-width: 768px) {
            .error-message {
                padding: 30px 40px;
                width: 350px;
            }

            .error-message h3 {
                font-size: 1rem;
            }

            .error-message p {
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="video-container">
            <video id="webcam" autoplay playsinline></video>
            <canvas id="canvas-overlay"></canvas>
            <canvas id="three-canvas"></canvas>
        </div>

        <div class="ui-overlay">
            <div class="header">
                <div class="logo">Girandola AR</div>
                <div class="status-panel">
                    <div class="status-item">
                        <span class="status-dot" id="camera-status"></span>
                        <span>Camera</span>
                    </div>
                    <div class="status-item">
                        <span class="status-dot" id="model-status"></span>
                        <span>AI Model</span>
                    </div>
                    <div class="status-item">
                        <span class="status-dot" id="detection-status"></span>
                        <span>Detection</span>
                    </div>
                </div>
            </div>

            <div class="corner-frame tl"></div>
            <div class="corner-frame tr"></div>
            <div class="corner-frame bl"></div>
            <div class="corner-frame br"></div>

            <div class="scan-line"></div>

            <div class="info-panel">
                <h3>Instructions</h3>
                <p>Point your camera at a computer mouse. The AI will detect it and summon a demon at its location. Move the mouse around to see the 3D model follow.</p>
            </div>

            <div class="detection-info">
                <h4>Detection Data</h4>
                <div class="detection-stats">
                    <div class="stat-row">
                        <span class="stat-label">Confidence</span>
                        <span class="stat-value" id="confidence-value">--</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">FPS</span>
                        <span class="stat-value" id="fps-value">--</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Objects</span>
                        <span class="stat-value" id="objects-value">0</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="loading-screen" id="loading-screen">
            <div class="loader"></div>
            <div class="loading-text">INITIALIZING</div>
            <div class="loading-status" id="loading-status">Loading TensorFlow.js...</div>
        </div>

        <div class="error-message" id="error-message">
            <h3>Camera Access Required</h3>
            <p>Please allow camera access to use this AR experience.</p>
        </div>
    </div>

    <!-- TensorFlow.js and COCO-SSD -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        // Global variables
        let video, canvas, ctx;
        let threeCanvas, scene, camera, renderer;
        let model;
        let demonModel = null;
        let targetPosition = { x: 0, y: 0, z: 0 };
        let currentPosition = { x: 0, y: 0, z: 0 };
        let isDetecting = false;
        let lastDetection = null;
        let frameCount = 0;
        let lastFpsTime = performance.now();
        let currentFps = 0;

        // Available 3D models in models folder
        const availableModels = [
            'models/aramabee.glb',
            'models/beagle.glb',
            'models/bottle.glb',
            'models/chicken.glb',
            'models/fountain.glb',
            'models/goat.glb',
            'models/hydrant.glb',
            'models/mouse.glb',
            'models/pigeon.glb',
            'models/sheep.glb',
            'models/snowman.glb'
        ];
        let currentModelPath = null;

        // DOM Elements
        const loadingScreen = document.getElementById('loading-screen');
        const loadingStatus = document.getElementById('loading-status');
        const cameraStatus = document.getElementById('camera-status');
        const modelStatus = document.getElementById('model-status');
        const detectionStatus = document.getElementById('detection-status');
        const confidenceValue = document.getElementById('confidence-value');
        const fpsValue = document.getElementById('fps-value');
        const objectsValue = document.getElementById('objects-value');
        const errorMessage = document.getElementById('error-message');

        // Initialize the application
        async function init() {
            try {
                // Setup video
                loadingStatus.textContent = 'Accessing camera...';
                await setupCamera();
                cameraStatus.classList.add('active');

                // Setup detection canvas
                setupCanvas();

                // Setup Three.js
                loadingStatus.textContent = 'Setting up 3D environment...';
                setupThreeJS();

                // Load COCO-SSD model
                loadingStatus.textContent = 'Loading AI detection model...';
                model = await cocoSsd.load();
                modelStatus.classList.add('active');

                // Load random 3D model
                loadingStatus.textContent = 'Loading 3D model...';
                await loadRandomModel();

                // Hide loading screen
                loadingScreen.classList.add('hidden');

                // Start detection loop
                detectFrame();

                // Start render loop
                animate();

            } catch (error) {
                console.error('Initialization error:', error);
                loadingStatus.textContent = 'Error: ' + error.message;
                if (error.name === 'NotAllowedError') {
                    errorMessage.classList.add('show');
                }
            }
        }

        // Setup webcam
        async function setupCamera() {
            video = document.getElementById('webcam');

            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'environment',
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            });

            video.srcObject = stream;

            return new Promise((resolve) => {
                video.onloadedmetadata = () => {
                    video.play();
                    resolve();
                };
            });
        }

        // Setup detection canvas
        function setupCanvas() {
            canvas = document.getElementById('canvas-overlay');
            ctx = canvas.getContext('2d');

            // Match canvas to video dimensions
            const updateCanvasSize = () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            };

            updateCanvasSize();
            window.addEventListener('resize', updateCanvasSize);
        }

        // Setup Three.js scene
        function setupThreeJS() {
            threeCanvas = document.getElementById('three-canvas');

            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 5;

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: threeCanvas,
                alpha: true,
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xff3366, 1, 10);
            pointLight.position.set(0, 2, 2);
            scene.add(pointLight);

            const pointLight2 = new THREE.PointLight(0x00ff88, 0.5, 10);
            pointLight2.position.set(-2, -1, 2);
            scene.add(pointLight2);

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // Select a random model from the available models
        function getRandomModelPath() {
            const randomIndex = Math.floor(Math.random() * availableModels.length);
            return availableModels[randomIndex];
        }

        // Load a 3D model from the given path
        async function loadModel(modelPath) {
            return new Promise((resolve, reject) => {
                const loader = new THREE.GLTFLoader();

                loader.load(
                    modelPath,
                    (gltf) => {
                        const loadedModel = gltf.scene;

                        // Scale and position the model
                        loadedModel.scale.set(0.5, 0.5, 0.5);
                        loadedModel.visible = false;

                        // Center the model
                        const box = new THREE.Box3().setFromObject(loadedModel);
                        const center = box.getCenter(new THREE.Vector3());
                        loadedModel.position.sub(center);

                        // Add to scene
                        scene.add(loadedModel);

                        const modelName = modelPath.split('/').pop().replace('.glb', '');
                        console.log(`Model loaded successfully: ${modelName}`);
                        resolve(loadedModel);
                    },
                    (progress) => {
                        const modelName = modelPath.split('/').pop().replace('.glb', '');
                        if (progress.total > 0) {
                            const percent = Math.round((progress.loaded / progress.total) * 100);
                            loadingStatus.textContent = `Loading ${modelName}... ${percent}%`;
                        } else {
                            loadingStatus.textContent = `Loading ${modelName}...`;
                        }
                    },
                    (error) => {
                        console.error('Error loading model:', error);
                        reject(error);
                    }
                );
            });
        }

        // Load a random 3D model
        async function loadRandomModel() {
            currentModelPath = getRandomModelPath();
            const modelName = currentModelPath.split('/').pop().replace('.glb', '');
            loadingStatus.textContent = `Loading ${modelName}...`;

            try {
                demonModel = await loadModel(currentModelPath);
            } catch (error) {
                console.error('Failed to load random model, creating fallback:', error);
                createFallbackModel();
            }
        }

        // Create fallback model if GLB fails to load
        function createFallbackModel() {
            console.log('Creating fallback demon model...');

            // Create a demon-like figure with basic geometry
            const group = new THREE.Group();

            // Body
            const bodyGeometry = new THREE.ConeGeometry(0.3, 0.8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b0000,
                metalness: 0.3,
                roughness: 0.7
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.4;
            group.add(body);

            // Head
            const headGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b0000,
                metalness: 0.3,
                roughness: 0.7
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 0.95;
            group.add(head);

            // Horns
            const hornGeometry = new THREE.ConeGeometry(0.05, 0.3, 8);
            const hornMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a0000,
                metalness: 0.5,
                roughness: 0.5
            });

            const leftHorn = new THREE.Mesh(hornGeometry, hornMaterial);
            leftHorn.position.set(-0.12, 1.15, 0);
            leftHorn.rotation.z = 0.3;
            group.add(leftHorn);

            const rightHorn = new THREE.Mesh(hornGeometry, hornMaterial);
            rightHorn.position.set(0.12, 1.15, 0);
            rightHorn.rotation.z = -0.3;
            group.add(rightHorn);

            // Eyes (glowing)
            const eyeGeometry = new THREE.SphereGeometry(0.04, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({
                color: 0xff3300,
                emissive: 0xff3300
            });

            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.08, 0.98, 0.15);
            group.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.08, 0.98, 0.15);
            group.add(rightEye);

            group.scale.set(0.8, 0.8, 0.8);
            group.visible = false;

            demonModel = group;
            scene.add(demonModel);
        }

        // Detection loop
        async function detectFrame() {
            if (!model || !video.readyState === 4) {
                requestAnimationFrame(detectFrame);
                return;
            }

            try {
                const predictions = await model.detect(video);

                // Calculate FPS
                frameCount++;
                const now = performance.now();
                if (now - lastFpsTime >= 1000) {
                    currentFps = frameCount;
                    frameCount = 0;
                    lastFpsTime = now;
                    fpsValue.textContent = currentFps;
                }

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Find mouse detections
                const mouseDetections = predictions.filter(p => p.class === 'bottle');
                objectsValue.textContent = mouseDetections.length;

                if (mouseDetections.length > 0) {
                    isDetecting = true;
                    detectionStatus.classList.add('detecting');

                    // Use the most confident detection
                    const bestDetection = mouseDetections.reduce((a, b) =>
                        a.score > b.score ? a : b
                    );

                    lastDetection = bestDetection;
                    confidenceValue.textContent = Math.round(bestDetection.score * 100) + '%';

                    // Draw bounding box
                    drawDetection(bestDetection);

                    // Update 3D model position
                    updateModelPosition(bestDetection);

                    // Show model only when mouse is detected
                    if (demonModel) {
                        demonModel.visible = true;
                    }
                } else {
                    isDetecting = false;
                    detectionStatus.classList.remove('detecting');
                    confidenceValue.textContent = '--';
                    lastDetection = null;

                    // Hide model immediately when no mouse detected
                    if (demonModel) {
                        demonModel.visible = false;
                    }
                }

            } catch (error) {
                console.error('Detection error:', error);
            }

            requestAnimationFrame(detectFrame);
        }

        // Draw detection box
        function drawDetection(detection) {
            const [x, y, width, height] = detection.bbox;

            // Scale to canvas size
            const scaleX = canvas.width / video.videoWidth;
            const scaleY = canvas.height / video.videoHeight;

            const scaledX = x * scaleX;
            const scaledY = y * scaleY;
            const scaledWidth = width * scaleX;
            const scaledHeight = height * scaleY;

            // Draw glowing box
            ctx.strokeStyle = '#ff3366';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ff3366';
            ctx.shadowBlur = 15;

            // Animated corners
            const cornerLength = 20;
            const time = performance.now() / 1000;
            const pulse = Math.sin(time * 4) * 0.3 + 0.7;

            ctx.globalAlpha = pulse;

            // Top-left corner
            ctx.beginPath();
            ctx.moveTo(scaledX, scaledY + cornerLength);
            ctx.lineTo(scaledX, scaledY);
            ctx.lineTo(scaledX + cornerLength, scaledY);
            ctx.stroke();

            // Top-right corner
            ctx.beginPath();
            ctx.moveTo(scaledX + scaledWidth - cornerLength, scaledY);
            ctx.lineTo(scaledX + scaledWidth, scaledY);
            ctx.lineTo(scaledX + scaledWidth, scaledY + cornerLength);
            ctx.stroke();

            // Bottom-left corner
            ctx.beginPath();
            ctx.moveTo(scaledX, scaledY + scaledHeight - cornerLength);
            ctx.lineTo(scaledX, scaledY + scaledHeight);
            ctx.lineTo(scaledX + cornerLength, scaledY + scaledHeight);
            ctx.stroke();

            // Bottom-right corner
            ctx.beginPath();
            ctx.moveTo(scaledX + scaledWidth - cornerLength, scaledY + scaledHeight);
            ctx.lineTo(scaledX + scaledWidth, scaledY + scaledHeight);
            ctx.lineTo(scaledX + scaledWidth, scaledY + scaledHeight - cornerLength);
            ctx.stroke();

            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;

            // Draw label
            ctx.fillStyle = 'rgba(255, 51, 102, 0.8)';
            ctx.fillRect(scaledX, scaledY - 25, 80, 22);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 12px Orbitron';
            ctx.fillText('Girandola', scaledX + 8, scaledY - 9);
        }

        // Update 3D model position based on detection - position ABOVE the mouse
        function updateModelPosition(detection) {
            const [x, y, width, height] = detection.bbox;

            // Calculate center X of bounding box, but use TOP of bounding box for Y
            const centerX = x + width / 2;
            const topY = y; // Use top of bounding box instead of center

            // Convert to normalized coordinates (-1 to 1)
            // Note: We flip X because video is mirrored
            const normalizedX = ((centerX / video.videoWidth) * 2 - 1);

            const normalizedY = -((topY / video.videoHeight) * 2 - 1);

            // Scale to 3D space - add extra Y offset to position model above mouse
            targetPosition.x = normalizedX * 3;
            targetPosition.y = normalizedY * 2 + 0.8; // Offset upward
            targetPosition.z = 0;
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            if (demonModel && demonModel.visible) {
                // Smooth interpolation to target position
                const lerpFactor = 0.1;
                currentPosition.x += (targetPosition.x - currentPosition.x) * lerpFactor;
                currentPosition.y += (targetPosition.y - currentPosition.y) * lerpFactor;
                currentPosition.z += (targetPosition.z - currentPosition.z) * lerpFactor;

                demonModel.position.x = currentPosition.x;
                demonModel.position.y = currentPosition.y;
                demonModel.position.z = currentPosition.z;

                // Add floating and rotation animation
                const time = performance.now() / 1000;
                demonModel.position.y += Math.sin(time * 2) * 0.1;
                demonModel.rotation.y += 0.02;
            }

            renderer.render(scene, camera);
        }

        // Start the application
        init();
    </script>
</body>
</html>
